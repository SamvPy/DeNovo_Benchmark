"""NovoB parser function."""

import logging
import os
from typing import Optional

import pandas as pd
from psm_utils import PSM, PSMList
from pyteomics import mgf
from tqdm import tqdm

from ...utils.proforma import parse_peptidoform
from .utils import mzml_reader

tqdm.pandas()


def novob_parser(
    result_path: str, mgf_path: str, mapping: dict, max_length=30, **kwargs
):
    """
    Return a `PSMList` from a ContraNovo search result and its MGF spectral file.

    Parameters
    ----------
    result_path: str
        Path to the search results.
    mgf_path: str
        Path to the MGF-file that was used to generate search results
    mapping: dict
        Mapping dictionary for converting engine-specific to
        unified modification and amino acid labels.
    max_length: int
        Any peptide sequence longer than this value will be ignored.

    Return
    ------
    psm_utils.PSMList
        The PSMList, representing the search results.
    """
    result_path = os.path.splitext(result_path)[0] + ".tsv"

    if mgf_path.lower().endswith('.mzml'):
        mgf_file = mzml_reader(mgf_path)
    else:
        mgf_file = pd.DataFrame(pd.DataFrame(mgf.read(mgf_path))["params"].tolist())

    _ = mgf_file.pop("charge")

    try:
        result = pd.read_csv(result_path, sep="\t", header=None).rename(
            columns={
                0: "Mcount",
                1: "charge",
                2: "peptide_mass",
                3: "sequence_forward",
                4: "mass_forward",
                5: "probability_forward",
                6: "sequence_reverse",
                7: "mass_reverse",
                8: "probability_reverse",
                9: "scans",
            }
        )
    except Exception:
        return PSMList(psm_list=[])

    try:
        result["scans"] = result.apply(
            lambda x: eval(x["scans"]).decode("utf-8"), axis=1
        )  # Remove b' ... '
    except Exception:
        pass
    run = os.path.basename(result_path)

    # Fuse the metadata of the spectra with result file
    joined_file = result.merge(mgf_file, on="scans")

    # Sanity checks
    assert len(result) == len(joined_file)
    if len(mgf_file) > len(joined_file):
        logging.info(
            f"{result_path} for NovoB:"
            f" dropped {len(mgf_file)-len(joined_file)} spectra."
        )

    # Parse to psm utils type format
    joined_file["precursor_mz"] = joined_file["pepmass"].apply(lambda x: x[0])

    joined_file = joined_file.progress_apply(
        lambda x: select_top_PSM(x, max_length, mapping, run), axis=1
    )
    joined_file = joined_file.dropna()

    psmlist = PSMList(psm_list=joined_file.tolist())
    return psmlist


def select_top_PSM(
    x: pd.Series, max_length: int, mapping: dict, run: Optional[str] = None
) -> Optional[PSM]:
    """
    Return the best scoring PSM from either the forward or reverse inference.

    NovoB always infers two peptide sequences, generated by an autoregressive model,
    starting the prediction from either the N- (forward) or C-term (reverse)

    Parameters
    ----------
    x: pd.Series
        The row from a dataframe with columns:
            - probability_forward
            - probability_reverse
            - mass_forward
            - mass_reverse
            - sequence_forward
            - sequence_reverse
            - charge
            - title
            - scans
            - precursor_mz
            - rtinseconds
    max_length: int
        Any peptide sequence longer than this value will be ignored.
    mapping: dict
        Mapping dictionary for converting engine-specific to
        unified modification and amino acid labels.
    run: Optional[str]
        The name of the mass spec run

    Return
    ------
    PSM (optional)
        If NovoB predicted a valid peptide for the spectrum, returns a PSM.
    """
    best = ""

    if x["probability_forward"] > x["probability_reverse"]:
        best = "forward"
    elif x["probability_forward"] < x["probability_reverse"]:
        best = "reverse"
    elif abs(x["mass_forward"]) < abs(x["mass_reverse"]):
        best = "forward"
    else:
        best = "reverse"

    peptidoform = eval(x[f"sequence_{best}"])[0] + "/" + str(int(x["charge"]))
    mass_error = x[f"mass_{best}"]
    proba = x[f"probability_{best}"]

    peptide = parse_peptidoform(peptidoform, mapping, max_length)
    if isinstance(peptide, type(None)):
        return None
    else:
        return PSM(
            peptidoform=peptide,
            spectrum_id=x["title"],
            run=run,
            score=proba,
            precursor_mz=x["precursor_mz"],
            retention_time=x["rtinseconds"]/60,
            source="NovoB",
            metadata={"ppm_error": mass_error, "scans": x["scans"]},
        )
